        -:    0:Source:handler.cpp
        -:    0:Graph:handler.gcno
        -:    0:Data:handler.gcda
        -:    0:Runs:1
        -:    1:#include "handler.hpp"
        -:    2:
        -:    3:// ============ Auxiliar functions =================
        -:    4:
       74:    5:bool validOperand( char c ){
       74:    6:	return c =='*' || c=='+' || c=='-' || c=='/';
        -:    7:}
       82:    8:bool validNum( char c ){
       82:    9:	return '0'<=c&&c<='9';
        -:   10:}
      134:   11:bool validChar( char c ){
     134*:   12:	return c==' ' || c=='\t' || validNum(c) || validOperand(c);
        -:   13:}
       30:   14:bool isNum( string s ){
      60*:   15:	for(char c: s) if( !validChar(c) ) return false;
       30:   16:	return true;
        -:   17:}
        -:   18:
        -:   19:// ========== Read after here ==========
        -:   20:
       52:   21:node *makeTree( vector<token> &tk, int &i, bool PRE ){
        -:   22:	// si ocurre una llamada con i>tk.size() => Sobran tokens
      52*:   23:	if( i>=tk.size() ){ i=tk.size()+5; return new node({-1,-1,' '}); }
        -:   24:	
        -:   25:	node *ans;
       52:   26:	if( tk[i].tipo ){
       30:   27:		ans = new node(tk[i++]);
        -:   28:	}else{
       22:   29:		ans = new node(tk[i++]);
       22:   30:		if(PRE){
       10:   31:			ans->L = makeTree(tk,i,PRE);
       10:   32:			ans->R = makeTree(tk,i,PRE);
        -:   33:		}else{
       12:   34:			ans->R = makeTree(tk,i,PRE);
       12:   35:			ans->L = makeTree(tk,i,PRE);
        -:   36:		}
        -:   37:	}
       52:   38:	return ans;
        -:   39:}
        -:   40:
       78:   41:string toStrNode( node *nodo, node *fa=0, bool rightChild=false ){
       78:   42:	string ans = "";
       78:   43:	if(nodo>0){
       36:   44:		bool par = true;
       36:   45:		if( fa==0 || nodo->tipo || fa->pre<=nodo->pre ) par = false;
       36:   46:		if( fa!=0 && !nodo->tipo && fa->pre==nodo->pre && rightChild  ) par = true;
        -:   47:		
       36:   48:		if(par) ans+="(";
       36:   49:		ans += toStrNode(nodo->L,nodo,0);
       36:   50:		if(nodo->tipo) ans += to_string(nodo->num);
       15:   51:		else ans += nodo->op;
       36:   52:		ans += toStrNode(nodo->R,nodo,1);
       36:   53:		if(par) ans+=")";
        -:   54:	}
       78:   55:	return ans;
        -:   56:}
        -:   57:
       16:   58:int eval( node *nodo ){
        -:   59:	int ans;
       16:   60:	if( nodo->tipo ) ans = nodo->num;
        -:   61:	else{
        7:   62:		int valL = eval(nodo->L), valR = eval(nodo->R);
        7:   63:		switch(nodo->op) {
        4:   64:			case '+':
        4:   65:				ans = valL+valR;
        4:   66:				break;
        1:   67:			case '-':
        1:   68:				ans = valL-valR;
        1:   69:				break;
        2:   70:			case '*':
        2:   71:				ans = valL*valR;
        2:   72:				break;
    #####:   73:			case '/':
    #####:   74:				ans = valL/valR;
    #####:   75:				break;
    #####:   76:			default:
    #####:   77:				break;
        -:   78:		}
        -:   79:	}
       16:   80:	return ans;
        -:   81:}
        -:   82:
        -:   83:/*
        -:   84: * If the list is empty, it's an error
        -:   85:*/
        8:   86:vector<token> tokenizer( string exp ){
        8:   87:	exp += " ";
        8:   88:    vector<token> ans;
       16:   89:	string str="";
      112:   90:	FOR(i,0,exp.size()){
      104:   91:		if( !validChar(exp[i]) ){
    #####:   92:			ans.clear();
    #####:   93:			return ans;
      104:   94:		}else if( exp[i]==' '|| exp[i]=='\t' ){
        -:   95:			// we found a token
       52:   96:			if( str.size() ){
       52:   97:				if( str.size()==1 && validOperand(str[0]) ){
       22:   98:					ans.push_back({0,-1, str[0]});
       30:   99:				}else if( isNum(str) ){
       30:  100:					ans.push_back({1, stoi(str), ' ' });
        -:  101:				}else{
    #####:  102:					ans.clear();
    #####:  103:					return ans;
        -:  104:				}
        -:  105:			}
       52:  106:			str = "";
       52:  107:		}else str += exp[i];
        -:  108:	}
        8:  109:	return ans;
        -:  110:}
        -:  111:
        -:  112:/*
        -:  113: * 0 | Todo bien
        -:  114: * 3 | Eror de al lexicografico
        -:  115: * 4 | Error en la exp
        -:  116:*/
        8:  117:pair<int,string> mainHandler( string option, string ord, string exp ){
        8:  118:	pair<int,string> ans = {0,""};
       16:  119:	vector<token> tk = tokenizer(exp);
       8*:  120:	if( tk.size()==0 ) ans = {3,""};
        -:  121:	else{
        8:  122:		int pos = 0;
        8:  123:		if( ord=="POST" ) reverse(tk.begin(),tk.end());
        8:  124:		node *n = makeTree(tk,pos,ord=="PRE");
        -:  125:		
        -:  126:		// si pos < tk.size() => No recorrio toda la lista
        -:  127:		// si pos = tk.size()+5 => Sobra un token
       8*:  128:		if(pos!=tk.size()) ans = {4,""};
        8:  129:		else if( option=="EVAL" ){
        -:  130:			//cout << eval(n) << '\n';
        2:  131:			ans.second = to_string( eval(n) );
        -:  132:		}else{ 
        -:  133:			//cout << toStrNode(n) << '\n';
        6:  134:			ans.second = toStrNode(n);
        -:  135:		}
        -:  136:	}
       16:  137:	return ans;
        -:  138:}
        -:  139:
        -:  140:/*
        -:  141:
        -:  142:MOSTRAR PRE - 2 + 1 3
        -:  143:// 2-(1+3)
        -:  144:
        -:  145:MOSTRAR POST 1 2 3 + -
        -:  146:// 1-(2+3)
        -:  147:
        -:  148:MOSTRAR POST 2 3 4 * +
        -:  149:// 2+3*4
        -:  150:
        -:  151:MOSTRAR PRE / 1 / 2 3
        -:  152:
        -:  153:*/
